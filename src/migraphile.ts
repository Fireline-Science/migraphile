#!/usr/bin/env node
/* eslint-disable @typescript-eslint/no-misused-promises */
import path from 'path'
import net from 'net'
import fs from 'fs'
import { highlight } from 'cli-highlight'
import chalk from 'chalk'
import { Pool, type PoolClient } from 'pg'
import { execSync, spawnSync } from 'child_process'
import assert from 'assert'
import * as dotenv from 'dotenv'
import * as fastq from 'fastq'
import type { queueAsPromised } from 'fastq'

type Task = FixDriftTask | OrmDoneTask

type OrmDoneTask = {
  name: 'orm_done'
  args?: string
}

type FixDriftTask = {
  name: 'fix_drift'
  args?: string
}

const processDir = process.cwd()

dotenv.config({
  path: path.join(processDir, '.env'),
})

const port = process.env.PORT || 5105

// We don't use DATABASE_URL because graphile migrate likes to override it
const appDbUrl = process.env.APP_DATABASE_URL
const rootDbUrl = process.env.ROOT_DATABASE_URL
const shadowDbUrl = process.env.SHADOW_DATABASE_URL
const ormDbUrl = process.env.ORM_DATABASE_URL
const outputFilePath = process.env.OUTPUT_FILE_PATH

const ormName = process.env.ORM_NAME || 'ORM'
const schemas = process.env.SCHEMAS || 'public'

const GRAPHILE_MIGRATE = `üíª ${chalk.italic.hex('#ff795b')('Graphile Migrate')}`
const MIGRA = chalk.italic.hex('#ff7d00')('Migra')
const ORM_NAME = chalk.italic.green(ormName)
const CURRENT_SQL = chalk.italic.cyan('current.sql')
const EMPTY_MIGRATION_TEXT = '-- Enter migration here\n'
const COMMAND_DESCRIPTION_TAB_SPACING = ' '.repeat(12)
const COMMAND_TAB_SPACING = ' '.repeat(8)

const getDbName = (dbUrl: string): string => {
  const url = new URL(dbUrl)
  return url.pathname.slice(1)
}

const prettyDb = (dbUrl: string): string => {
  const dbName = getDbName(dbUrl)

  if (dbUrl === shadowDbUrl) {
    return `üëª ${chalk.italic.yellow(dbName)}`
  }

  if (dbUrl === ormDbUrl) {
    return `‚öôÔ∏è ${chalk.italic.green(dbName)}`
  }

  if (dbUrl === rootDbUrl) {
    return `üîë ${chalk.italic.red(dbName)}`
  }

  return `üì¶ ${chalk.italic.cyan(dbName)}`
}

const highlightOptions = {
  language: 'sql',
  ignoreIllegals: true,
  theme: {
    keyword: chalk.yellow.bold,
    type: chalk.red.bold,
  },
}

const taskMap: {
  [taskName in Task['name']]: {
    usage: string
    description: string[]
    method: Function
  }
} = {
  orm_done: {
    usage: `${chalk.bold('orm_done')}`,
    description: [
      `Called by ${ORM_NAME} when it has finished generating a migration.`,
      `This will update the current migration file with the migration generated by ${ORM_NAME}.`,
      `This will also run the migration on the shadow database.`,
    ],
    method: async (): Promise<void> => {
      await ormDone()
    },
  },
  fix_drift: {
    usage: `${chalk.bold('fix_drift')}`,
    description: [
      `Called by ${GRAPHILE_MIGRATE} when drift detection needs to happen. Should be part of the beforeCurrent and afterAllMigrations hooks.`,
      `This will compare the current database to the shadow database and revert the current database to the shadow database state.`,
    ],
    method: async (): Promise<void> => {
      await fixDriftAction()
    },
  },
}

const migraImage = process.env.MIGRA_IMAGE || 'firelinescience/migra:latest'

const runMigra = async (from: string, to: string): Promise<string> => {
  await waitForDb(from)
  await waitForDb(to)

  console.log(
    `üîç Comparing ${prettyDb(from)} to ${prettyDb(to)} using ${MIGRA}...`,
  )

  let revertSql = ''

  // Split the schemas string into an array
  const schemaList = schemas.split(',')

  try {
    for (const schema of schemaList) {
      console.log(
        `üîç ${MIGRA} ‚Üí Comparing schema: ${chalk.bold(schema.trim())}...`,
      )
      const args = [
        'run',
        '--rm',
        '-i',
        '--network',
        'host',
        migraImage,
        'migra',
        from.replace('postgres://', 'postgresql://'),
        to.replace('postgres://', 'postgresql://'),
        '--with-privileges',
        '--unsafe',
        `--schema=${schema.trim()}`, // Use the current schema in the loop
      ]
      const proc = spawnSync('docker', args)

      // Append the output of each schema to revertSql
      revertSql += proc.stdout.toString('utf8')
    }
  } catch (error) {
    console.error(`Error running ${MIGRA}:`, error)
  }

  return revertSql
}

const fixDrift = async (): Promise<void> => {
  console.log(`ü§î Looking for drift...`)
  if (!shadowDbUrl || !appDbUrl) {
    console.error('üö® No given database URLs for diff, exiting gracefully.')
    process.exit(0)
  }

  const revertSql = await runMigra(appDbUrl, shadowDbUrl)

  const pool = new Pool({
    connectionString: appDbUrl,
  })

  const client = await pool.connect()

  try {
    if (revertSql) {
      console.log(
        'üö® Drift detected! Reverting database to shadow database state, sql below:',
      )
      console.log(highlight(revertSql, highlightOptions))

      await client.query(revertSql)
    } else {
      console.log('üì¢ No drift detected, no need to revert.')
    }
  } catch (error) {
    console.error('Error executing SQL:', error)
  } finally {
    client.release()
    await pool.end()
  }
}

const getProcessCommand = (pid: string): string | null => {
  try {
    return execSync(`ps -ww -p ${pid} -o args=`).toString().trim()
  } catch (err) {
    return null
  }
}

const getParentPid = (pid: string): string | null => {
  try {
    return execSync(`ps -p ${pid} -o ppid=`).toString().trim()
  } catch (err) {
    return null
  }
}

const findGraphileMigrateCommand = (
  pid: string,
): { graphileMigratePid: string; command: string } | null => {
  let currentPid: string | null = pid

  console.log(`Starting search for 'graphile-migrate' with initial PID: ${pid}`)

  while (currentPid && currentPid !== '1') {
    console.log(`Checking process with PID: ${currentPid}`)

    const command = getProcessCommand(currentPid)
    if (command) {
      console.log(`Command for PID ${currentPid}: ${command}`)
      if (command.includes('graphile-migrate')) {
        const tokens = command.split(/\s+/)
        const index = tokens.findIndex((token) =>
          token.includes('graphile-migrate'),
        )
        if (index !== -1 && tokens.length > index + 1) {
          console.log(
            `'graphile-migrate' found in PID ${currentPid}. Returning command: ${tokens[index + 1]}`,
          )
          return {
            graphileMigratePid: currentPid,
            command: tokens[index + 1],
          }
        }
      }
    } else {
      console.log(`No command found for PID ${currentPid}`)
    }
    currentPid = getParentPid(currentPid)
  }

  console.log(`'graphile-migrate' not found for initial PID: ${pid}`)
  return null // Return null if 'graphile-migrate' was not found
}

// We need to look up the process tree to find the "graphile-migrate" command that was ran.
// We then need to create temporary file that contains graphile migrates PID, and a number
// that indicates the number of times this command has been ran within that parent PID.
const getExecutionCount = (pid: string): number => {
  try {
    const count = fs.readFileSync(`/tmp/graphile-migrate-${pid}.txt`, 'utf8')
    return parseInt(count, 10) || 0
  } catch (err) {
    return 0
  }
}

const setExecutionCount = (pid: string, count: number): void => {
  fs.writeFileSync(`/tmp/graphile-migrate-${pid}.txt`, count.toString())
}

const checkAndIncrementExecutionCount = (pid: string): void => {
  const currentCount = getExecutionCount(pid)
  setExecutionCount(pid, currentCount + 1)
  if (currentCount > 0) {
    console.error(
      `üö´ Draft detection already accounted for (${currentCount} time before). Exiting gracefully.`,
    )
    process.exit(0)
  }
}

const fixDriftAction = async (): Promise<void> => {
  const parentGmContext = findGraphileMigrateCommand(process.pid.toString())

  if (!parentGmContext) {
    console.error(
      'Could not find graphile-migrate command, this should only be ran from within a graphile-migrate command.',
    )
    process.exit(1)
  }

  // This command should only be ran for 'commit' and 'watch' commands using Typescripts type guard
  const isValidCommand = (
    command: string,
  ): command is 'commit' | 'watch' | 'uncommit' =>
    command === 'commit' || command === 'watch' || command === 'uncommit'

  if (!isValidCommand(parentGmContext.command)) {
    console.error('üö´ Not handling drift for this command, exiting gracefully.')
    return
  }

  // We only want to run this command once per parent PID when the command is 'commit'
  if (parentGmContext.command === 'commit') {
    checkAndIncrementExecutionCount(parentGmContext.graphileMigratePid)
  }

  await fixDrift()
}

const ormDone = async (): Promise<void> => {
  console.log(`üéâ ${ORM_NAME} finished!`)
  assert(shadowDbUrl !== undefined, 'SHADOW_DATABASE_URL is required')
  assert(ormDbUrl !== undefined, 'ORM_DATABASE_URL is required')
  assert(outputFilePath !== undefined, 'OUTPUT_FILE_PATH is required')

  let diffSql = await runMigra(shadowDbUrl, ormDbUrl)
  if (!diffSql) {
    diffSql = EMPTY_MIGRATION_TEXT
    console.log('üì¢ No migrations needed.')
  }

  // Check if file contents are different before writing
  let currentContent = ''
  if (fs.existsSync(outputFilePath)) {
    currentContent = fs.readFileSync(outputFilePath, 'utf-8')
  }

  if (currentContent !== diffSql) {
    console.log(`üìú See SQL below:`)
    console.log(highlight(diffSql, highlightOptions))

    fs.writeFileSync(outputFilePath, diffSql)
    console.log(`‚úÖ Updated ${CURRENT_SQL} migration file.`)
  } else {
    console.log(`üìå No changes needed in ${CURRENT_SQL}.`)
  }
}

const withClient = async (
  dbConnectionString: string,
  fn: (client: PoolClient) => Promise<void>,
): Promise<void> => {
  const pool = new Pool({
    connectionString: dbConnectionString,
  })

  const client = await pool.connect()

  try {
    await fn(client)
  } catch (e) {
    console.error('Error executing SQL:', e)
  }

  client.release()
  await pool.end()
}

const waitForDb = async (dbConnectionString: string): Promise<void> => {
  console.log(
    `üîç Checking availability for ${prettyDb(dbConnectionString)} ... `,
  )

  const startTime = Date.now()
  const TIMEOUT_MS = 60 * 1000 // 1 minute in milliseconds

  while (true) {
    if (Date.now() - startTime > TIMEOUT_MS) {
      throw new Error(
        `üïê Timeout: Unable to connect to ${prettyDb(dbConnectionString)} after 1 minute.`,
      )
    }

    try {
      await withClient(dbConnectionString, async (client) => {
        await client.query('SELECT 1')
        console.log(`‚úÖ ${prettyDb(dbConnectionString)} is available!`)
      })
      break
    } catch (e) {
      console.log(
        `üî¥ ${prettyDb(dbConnectionString)} is not available yet, waiting 2 seconds...`,
      )
      await new Promise((resolve) => setTimeout(resolve, 2000))
    }
  }
}

const ensureDbExists = async (dbConnectionString: string): Promise<boolean> => {
  console.log(`üîç Ensuring existence for ${prettyDb(dbConnectionString)} ... `)
  let wasCreated = false

  // If dbConnectionString is rootDbUrl, we need to connect to the default postgres db
  assert(rootDbUrl !== undefined, 'ROOT_DATABASE_URL is required')
  assert(appDbUrl !== undefined, 'DATABASE_URL is required')
  const urlToUse = dbConnectionString === rootDbUrl ? appDbUrl : rootDbUrl

  await withClient(urlToUse, async (client) => {
    let exists = false
    try {
      // Check if db exists first
      const { rows } = await client.query(
        `SELECT datname
         FROM pg_catalog.pg_database
         WHERE lower(datname) = lower('${getDbName(dbConnectionString)}')`,
      )
      exists = rows.length > 0
    } catch (e) {
      exists = false
    }

    if (!exists) {
      await client.query(`CREATE DATABASE ${getDbName(dbConnectionString)}`)
      console.log(`üöÄ ${prettyDb(dbConnectionString)} created!`)
      wasCreated = true
    } else {
      console.log(`‚úÖ ${prettyDb(dbConnectionString)} exists.`)
    }
  })
  return wasCreated
}

const q: queueAsPromised<Task> = fastq.promise(asyncWorker, 1)

async function asyncWorker(arg: Task): Promise<void> {
  await taskMap[arg.name].method(arg)
}

const runCommand = async (
  command: string | undefined,
  args: string,
): Promise<void> => {
  if (!command) {
    console.error(`‚ùå No command provided`)
    return
  }

  console.log(
    `üì° Migration server received command: ${chalk.bold.green(command)} with args: ${chalk.bold.green(args)}`,
  )
  if (!(command in taskMap)) {
    console.error(`‚ùå Unknown command: ${chalk.bold.red(command)}`)
    process.exit(1)
  }
  const commandToRun = command as Task['name']
  await q.push({ name: commandToRun, args })
}

const main = async (): Promise<void> => {
  const command = process.argv[2]
  const rest = process.argv.slice(3)

  if (command) {
    await runCommand(command, rest.join(' '))
    process.exit(0)
  }

  const server = net.createServer((socket) => {
    socket.on('data', async (data) => {
      const [command, ...rest] = data.toString().trim().split(' ')

      await runCommand(command, rest.join(' '))
    })
  })

  console.log(`üì• Pulling ${MIGRA} image [${chalk.italic(migraImage)}]...`)
  spawnSync('docker', ['pull', migraImage])

  assert(ormDbUrl !== undefined, 'ORM_DATABASE_URL is required')
  assert(shadowDbUrl !== undefined, 'SHADOW_DATABASE_URL is required')
  assert(rootDbUrl !== undefined, 'ROOT_DATABASE_URL is required')
  assert(appDbUrl !== undefined, 'DATABASE_URL is required')
  await ensureDbExists(rootDbUrl)
  await ensureDbExists(appDbUrl)
  await ensureDbExists(shadowDbUrl)
  await ensureDbExists(ormDbUrl)

  server.listen(port, async () => {
    console.log(
      `üì° Migration server listening on port ${chalk.bold.green(port)}`,
    )
    console.log(`
    Welcome to the Migration server! This server is used to generate migrations
    between the shadow database and the ${ORM_NAME} database. It can also be used to update
    your local database to the shadow database state including the current migration using
    ${GRAPHILE_MIGRATE}.
    
    ${chalk.bold('Managed schemas:')}
${schemas
  .split(',')
  .map((s) => `${COMMAND_TAB_SPACING}* ${s}`)
  .join('\n')}
  
    ${chalk.bold('migration output file:')} ${outputFilePath ? chalk.italic.bold(path.relative(process.cwd(), outputFilePath)) : chalk.red('not set')}
    
    ${chalk.bold('root database:')} ${prettyDb(rootDbUrl)}
      * This is the database that is used to create other databases.
    
    ${chalk.bold('app database:')} ${prettyDb(appDbUrl)}
      * This is the database that is used by the app.
    
    ${chalk.bold('orm database:')} ${prettyDb(ormDbUrl)}
      * This is the database that is used by ${ORM_NAME}. It is always in sync with the
        ${ORM_NAME} models. When a change is made to the ${ORM_NAME} models, a
        migration is automatically generated.
    
    ${chalk.bold('shadow database:')} ${prettyDb(shadowDbUrl)}
      * This is the database that is used by ${GRAPHILE_MIGRATE}. It is always in sync
        with the latest migrations ${chalk.italic.bold('excluding')} the current migration.
        
    To run a command, use the following syntax:
        ${chalk.bold.green('echo "command args" | nc localhost 5105')}
        or
        ${chalk.bold.green('migration-server command args')}
        
    Available commands:
${Object.entries(taskMap)
  .map(([, { usage, description }]) => {
    return `${COMMAND_TAB_SPACING}${usage}\n${description
      .map((d) => `${COMMAND_DESCRIPTION_TAB_SPACING}${d}`)
      .join('\n')}`
  })
  .join('\n\n')}
  `)
  })
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})
