#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-misused-promises */
const path_1 = __importDefault(require("path"));
const net_1 = __importDefault(require("net"));
const fs_1 = __importDefault(require("fs"));
const cli_highlight_1 = require("cli-highlight");
const chalk_1 = __importDefault(require("chalk"));
const pg_1 = require("pg");
const child_process_1 = require("child_process");
const assert_1 = __importDefault(require("assert"));
const dotenv = __importStar(require("dotenv"));
const fastq = __importStar(require("fastq"));
const processDir = process.cwd();
dotenv.config({
    path: path_1.default.join(processDir, '.env'),
});
const port = process.env.PORT || 5105;
const dbUri = process.env.DB_URI;
const rootDbUri = process.env.ROOT_DB_URI;
const shadowDbUri = process.env.SHADOW_DB_URI;
const ormDbUri = process.env.ORM_DB_URI;
const outputFilePath = process.env.OUTPUT_FILE_PATH;
const ormName = process.env.ORM_NAME || 'ORM';
const schemas = process.env.SCHEMAS || 'public';
const GRAPHILE_MIGRATE = `ðŸ’» ${chalk_1.default.italic.hex('#ff795b')('Graphile Migrate')}`;
const MIGRA = chalk_1.default.italic.hex('#ff7d00')('Migra');
const ORM_NAME = chalk_1.default.italic.green(ormName);
const CURRENT_SQL = chalk_1.default.italic.cyan('current.sql');
const EMPTY_MIGRATION_TEXT = '-- Enter migration here\n';
const COMMAND_DESCRIPTION_TAB_SPACING = ' '.repeat(12);
const COMMAND_TAB_SPACING = ' '.repeat(8);
const getDbName = (dbUri) => {
    const url = new URL(dbUri);
    return url.pathname.slice(1);
};
const prettyDb = (dbUri) => {
    const dbName = getDbName(dbUri);
    if (dbUri === shadowDbUri) {
        return `ðŸ‘» ${chalk_1.default.italic.yellow(dbName)}`;
    }
    if (dbUri === ormDbUri) {
        return `âš™ï¸ ${chalk_1.default.italic.green(dbName)}`;
    }
    if (dbUri === rootDbUri) {
        return `ðŸ”‘ ${chalk_1.default.italic.red(dbName)}`;
    }
    return `ðŸ“¦ ${chalk_1.default.italic.cyan(dbName)}`;
};
const highlightOptions = {
    language: 'sql',
    ignoreIllegals: true,
    theme: {
        keyword: chalk_1.default.yellow.bold,
        type: chalk_1.default.red.bold,
    },
};
const taskMap = {
    orm_done: {
        usage: `${chalk_1.default.bold('orm_done')}`,
        description: [
            `Called by ${ORM_NAME} when it has finished generating a migration.`,
            `This will update the current migration file with the migration generated by ${ORM_NAME}.`,
            `This will also run the migration on the shadow database.`,
        ],
        method: () => __awaiter(void 0, void 0, void 0, function* () {
            yield ormDone();
        }),
    },
    fix_drift: {
        usage: `${chalk_1.default.bold('fix_drift')}`,
        description: [
            `Called by ${GRAPHILE_MIGRATE} when drift detection needs to happen. Should be part of the beforeCurrent and afterAllMigrations hooks.`,
            `This will compare the current database to the shadow database and revert the current database to the shadow database state.`,
        ],
        method: () => __awaiter(void 0, void 0, void 0, function* () {
            yield fixDriftAction();
        }),
    },
};
const migraImage = process.env.MIGRA_IMAGE || 'firelinescience/migra:latest';
const runMigra = (from, to) => __awaiter(void 0, void 0, void 0, function* () {
    console.log(`ðŸ” Comparing ${prettyDb(from)} to ${prettyDb(to)} using ${MIGRA}...`);
    let revertSql = '';
    // Split the schemas string into an array
    const schemaList = schemas.split(',');
    try {
        for (const schema of schemaList) {
            console.log(`ðŸ” ${MIGRA} â†’ Comparing schema: ${chalk_1.default.bold(schema.trim())}...`);
            const args = [
                'run',
                '--rm',
                '-i',
                '--network',
                'host',
                migraImage,
                'migra',
                from.replace('postgres://', 'postgresql://'),
                to.replace('postgres://', 'postgresql://'),
                '--with-privileges',
                '--unsafe',
                `--schema=${schema.trim()}`, // Use the current schema in the loop
            ];
            const proc = (0, child_process_1.spawnSync)('docker', args);
            // Append the output of each schema to revertSql
            revertSql += proc.stdout.toString('utf8');
        }
    }
    catch (error) {
        console.error(`Error running ${MIGRA}:`, error);
    }
    return revertSql;
});
const fixDrift = () => __awaiter(void 0, void 0, void 0, function* () {
    console.log(`ðŸ¤” Looking for drift...`);
    if (!shadowDbUri || !dbUri) {
        console.error('ðŸš¨ No given database URIs for diff, exiting gracefully.');
        process.exit(0);
    }
    const revertSql = yield runMigra(dbUri, shadowDbUri);
    const pool = new pg_1.Pool({
        connectionString: dbUri,
    });
    const client = yield pool.connect();
    try {
        if (revertSql) {
            console.log('ðŸš¨ Drift detected! Reverting database to shadow database state, sql below:');
            console.log((0, cli_highlight_1.highlight)(revertSql, highlightOptions));
            yield client.query(revertSql);
        }
        else {
            console.log('ðŸ“¢ No drift detected, no need to revert.');
        }
    }
    catch (error) {
        console.error('Error executing SQL:', error);
    }
    finally {
        client.release();
        yield pool.end();
    }
});
const getProcessCommand = (pid) => {
    try {
        return (0, child_process_1.execSync)(`ps -p ${pid} -o command=`).toString().trim();
    }
    catch (err) {
        return null;
    }
};
const getParentPid = (pid) => {
    try {
        return (0, child_process_1.execSync)(`ps -p ${pid} -o ppid=`).toString().trim();
    }
    catch (err) {
        return null;
    }
};
const findGraphileMigrateCommand = (pid) => {
    let currentPid = pid;
    while (currentPid && currentPid !== '1') {
        // Stop when reaching PID 1 or if PID is null
        const command = getProcessCommand(currentPid);
        if (command && command.includes('graphile-migrate')) {
            const tokens = command.split(/\s+/);
            const index = tokens.findIndex((token) => token.includes('graphile-migrate'));
            if (index !== -1 && tokens.length > index + 1) {
                return {
                    graphileMigratePid: currentPid,
                    command: tokens[index + 1],
                };
            }
        }
        currentPid = getParentPid(currentPid);
    }
    return null; // Return null if 'graphile-migrate' was not found
};
// We need to look up the process tree to find the "graphile-migrate" command that was ran.
// We then need to create temporary file that contains graphile migrates PID, and a number
// that indicates the number of times this command has been ran within that parent PID.
const getExecutionCount = (pid) => {
    try {
        const count = fs_1.default.readFileSync(`/tmp/graphile-migrate-${pid}.txt`, 'utf8');
        return parseInt(count, 10) || 0;
    }
    catch (err) {
        return 0;
    }
};
const setExecutionCount = (pid, count) => {
    fs_1.default.writeFileSync(`/tmp/graphile-migrate-${pid}.txt`, count.toString());
};
const checkAndIncrementExecutionCount = (pid) => {
    const currentCount = getExecutionCount(pid);
    setExecutionCount(pid, currentCount + 1);
    if (currentCount > 0) {
        console.error(`ðŸš« Draft detection already accounted for (${currentCount} time before). Exiting gracefully.`);
        process.exit(0);
    }
};
const fixDriftAction = () => __awaiter(void 0, void 0, void 0, function* () {
    const parentGmContext = findGraphileMigrateCommand(process.pid.toString());
    if (!parentGmContext) {
        console.error('Could not find graphile-migrate command, this should only be ran from within a graphile-migrate command.');
        process.exit(1);
    }
    // This command should only be ran for 'commit' and 'watch' commands using Typescripts type guard
    const isValidCommand = (command) => command === 'commit' || command === 'watch' || command === 'uncommit';
    if (!isValidCommand(parentGmContext.command)) {
        console.error('ðŸš« Not handling drift for this command, exiting gracefully.');
        return;
    }
    // We only want to run this command once per parent PID when the command is 'commit'
    if (parentGmContext.command === 'commit') {
        checkAndIncrementExecutionCount(parentGmContext.graphileMigratePid);
    }
    yield fixDrift();
});
const ormDone = () => __awaiter(void 0, void 0, void 0, function* () {
    console.log(`ðŸŽ‰ ${ORM_NAME} finished!`);
    (0, assert_1.default)(shadowDbUri !== undefined, 'SHADOW_DB_URI is required');
    (0, assert_1.default)(ormDbUri !== undefined, 'ORM_DB_URI is required');
    (0, assert_1.default)(outputFilePath !== undefined, 'OUTPUT_FILE_PATH is required');
    let diffSql = yield runMigra(shadowDbUri, ormDbUri);
    if (!diffSql) {
        diffSql = EMPTY_MIGRATION_TEXT;
        console.log('ðŸ“¢ No migrations needed.');
    }
    // Check if file contents are different before writing
    let currentContent = '';
    if (fs_1.default.existsSync(outputFilePath)) {
        currentContent = fs_1.default.readFileSync(outputFilePath, 'utf-8');
    }
    if (currentContent !== diffSql) {
        console.log(`ðŸ“œ See SQL below:`);
        console.log((0, cli_highlight_1.highlight)(diffSql, highlightOptions));
        fs_1.default.writeFileSync(outputFilePath, diffSql);
        console.log(`âœ… Updated ${CURRENT_SQL} migration file.`);
    }
    else {
        console.log(`ðŸ“Œ No changes needed in ${CURRENT_SQL}.`);
    }
});
const withClient = (dbConnectionString, fn) => __awaiter(void 0, void 0, void 0, function* () {
    const pool = new pg_1.Pool({
        connectionString: dbConnectionString,
    });
    const client = yield pool.connect();
    try {
        yield fn(client);
    }
    catch (e) {
        console.error('Error executing SQL:', e);
    }
    client.release();
    yield pool.end();
});
const waitForDb = (dbConnectionString) => __awaiter(void 0, void 0, void 0, function* () {
    console.log(`ðŸ” Checking availability for ${prettyDb(dbConnectionString)} ... `);
    const startTime = Date.now();
    const TIMEOUT_MS = 60 * 1000; // 1 minute in milliseconds
    while (true) {
        if (Date.now() - startTime > TIMEOUT_MS) {
            throw new Error(`ðŸ• Timeout: Unable to connect to ${prettyDb(dbConnectionString)} after 1 minute.`);
        }
        try {
            yield withClient(dbConnectionString, (client) => __awaiter(void 0, void 0, void 0, function* () {
                yield client.query('SELECT 1');
                console.log(`âœ… ${prettyDb(dbConnectionString)} is available!`);
            }));
            break;
        }
        catch (e) {
            console.log(`ðŸ”´ ${prettyDb(dbConnectionString)} is not available yet, waiting 2 seconds...`);
            yield new Promise((resolve) => setTimeout(resolve, 2000));
        }
    }
});
const ensureDbExists = (dbConnectionString) => __awaiter(void 0, void 0, void 0, function* () {
    console.log(`ðŸ” Ensuring existence for ${prettyDb(dbConnectionString)} ... `);
    let wasCreated = false;
    // If dbConnectionString is rootDbUri, we need to connect to the default postgres db
    (0, assert_1.default)(rootDbUri !== undefined, 'ROOT_DB_URI is required');
    (0, assert_1.default)(dbUri !== undefined, 'DB_URI is required');
    const uriToUse = dbConnectionString === rootDbUri ? dbUri : rootDbUri;
    yield withClient(uriToUse, (client) => __awaiter(void 0, void 0, void 0, function* () {
        let exists = false;
        try {
            // Check if db exists first
            const { rows } = yield client.query(`SELECT datname
         FROM pg_catalog.pg_database
         WHERE lower(datname) = lower('${getDbName(dbConnectionString)}')`);
            exists = rows.length > 0;
        }
        catch (e) {
            exists = false;
        }
        if (!exists) {
            yield client.query(`CREATE DATABASE ${getDbName(dbConnectionString)}`);
            console.log(`ðŸš€ ${prettyDb(dbConnectionString)} created!`);
            wasCreated = true;
        }
        else {
            console.log(`âœ… ${prettyDb(dbConnectionString)} exists.`);
        }
    }));
    return wasCreated;
});
const q = fastq.promise(asyncWorker, 1);
function asyncWorker(arg) {
    return __awaiter(this, void 0, void 0, function* () {
        yield taskMap[arg.name].method(arg);
    });
}
const runCommand = (command, args) => __awaiter(void 0, void 0, void 0, function* () {
    if (!command) {
        console.error(`âŒ No command provided`);
        return;
    }
    console.log(`ðŸ“¡ Migration server received command: ${chalk_1.default.bold.green(command)} with args: ${chalk_1.default.bold.green(args)}`);
    if (!(command in taskMap)) {
        console.error(`âŒ Unknown command: ${chalk_1.default.bold.red(command)}`);
        process.exit(1);
    }
    const commandToRun = command;
    yield q.push({ name: commandToRun, args });
});
const main = () => __awaiter(void 0, void 0, void 0, function* () {
    const command = process.argv[2];
    const rest = process.argv.slice(3);
    if (dbUri) {
        yield waitForDb(dbUri);
    }
    if (command !== 'migrate' && command !== 'init' && command !== 'run') {
        // Migrate can be run without root db or shadow db
        (0, assert_1.default)(rootDbUri !== undefined, 'ROOT_DB_URI is required');
        (0, assert_1.default)(shadowDbUri !== undefined, 'SHADOW_DB_URI is required');
        yield ensureDbExists(rootDbUri);
        yield ensureDbExists(shadowDbUri);
    }
    if (command) {
        yield runCommand(command, rest.join(' '));
        process.exit(0);
    }
    const server = net_1.default.createServer((socket) => {
        socket.on('data', (data) => __awaiter(void 0, void 0, void 0, function* () {
            const [command, ...rest] = data.toString().trim().split(' ');
            yield runCommand(command, rest.join(' '));
        }));
    });
    console.log(`ðŸ“¥ Pulling ${MIGRA} image [${chalk_1.default.italic(migraImage)}]...`);
    (0, child_process_1.spawnSync)('docker', ['pull', migraImage]);
    (0, assert_1.default)(ormDbUri !== undefined, 'ORM_DB_URI is required');
    (0, assert_1.default)(shadowDbUri !== undefined, 'SHADOW_DB_URI is required');
    (0, assert_1.default)(rootDbUri !== undefined, 'ROOT_DB_URI is required');
    (0, assert_1.default)(dbUri !== undefined, 'DB_URI is required');
    yield ensureDbExists(ormDbUri);
    server.listen(port, () => __awaiter(void 0, void 0, void 0, function* () {
        console.log(`ðŸ“¡ Migration server listening on port ${chalk_1.default.bold.green(port)}`);
        console.log(`
    Welcome to the Migration server! This server is used to generate migrations
    between the shadow database and the ${ORM_NAME} database. It can also be used to update
    your local database to the shadow database state including the current migration using
    ${GRAPHILE_MIGRATE}.
    
    ${chalk_1.default.bold('Managed schemas:')}
${schemas
            .split(',')
            .map((s) => `${COMMAND_TAB_SPACING}* ${s}`)
            .join('\n')}
  
    ${chalk_1.default.bold('migration output file:')} ${outputFilePath ? chalk_1.default.italic.bold(path_1.default.relative(process.cwd(), outputFilePath)) : chalk_1.default.red('not set')}
    
    ${chalk_1.default.bold('root database:')} ${prettyDb(rootDbUri)}
      * This is the database that is used to create other databases.
    
    ${chalk_1.default.bold('app database:')} ${prettyDb(dbUri)}
      * This is the database that is used by the app.
    
    ${chalk_1.default.bold('orm database:')} ${prettyDb(ormDbUri)}
      * This is the database that is used by ${ORM_NAME}. It is always in sync with the
        ${ORM_NAME} models. When a change is made to the ${ORM_NAME} models, a
        migration is automatically generated.
    
    ${chalk_1.default.bold('shadow database:')} ${prettyDb(shadowDbUri)}
      * This is the database that is used by ${GRAPHILE_MIGRATE}. It is always in sync
        with the latest migrations ${chalk_1.default.italic.bold('excluding')} the current migration.
        
    To run a command, use the following syntax:
        ${chalk_1.default.bold.green('echo "command args" | nc localhost 5105')}
        or
        ${chalk_1.default.bold.green('migration-server command args')}
        
    Available commands:
${Object.entries(taskMap)
            .map(([, { usage, description }]) => {
            return `${COMMAND_TAB_SPACING}${usage}\n${description
                .map((d) => `${COMMAND_DESCRIPTION_TAB_SPACING}${d}`)
                .join('\n')}`;
        })
            .join('\n\n')}
  `);
    }));
});
main().catch((e) => {
    console.error(e);
    process.exit(1);
});
//# sourceMappingURL=migraphile.js.map